# 单页面应用集成开发环境设计
##定义
**单页面应用（SPA，Simple Page Application）**  
>不同于传统的链接跳转，整个页面刷新的web站点，单页面应用采用ajax配合history API（或hashchange）技术异步加载数据，并在前端将数据和模板渲染成html片段，动态插入页面中，实现无刷新页面跳转。单页应用在提供更好的用户体验的同时，对前端的工程化有更高的要求。对于加载性能和用户体验要求更高的wap端，一般都会采用单页面的模式开发设计产品。

**集成开发环境**
>比较正式的说法：将前端研发领域中各种分散的技术元素集中在一起，并对常见的前端开发问题、不足、缺陷和需求，所提出的一种解决问题的方案。（引用自<https://github.com/fouber/blog/issues/1>）
简单的说，就是将前端开发过程中必须面临的问题如：本地开发、联调测试、产品发布、js模块化方案、框架集成、静态资源定位、文件名md5戳（去缓存）、预编译、代码压缩合并混淆、性能优化、组件化和组件库等等诸多问题串联起来，形成一个自动化的工作流。旨在提高开发效率和项目的可维护性、降低团队协作成本、减少重复的手工劳动和因此带来的人为失误。  
好的集成开发环境不仅能提升开发效率，更直接关系到整个产品的用户体验。用户体验的提升绝不仅仅是UE出两张设计稿、PM换个交互方式能解决的。比如说，离开系统结构谈性能优化，注定只能临时地解决个别页面的性能问题。

## 基本功能（集成环境的最小功能集）
**本地开发服务器环境**
>一个好的本地开发服务器应该最好能尽量模拟线上的服务器环境，本地开发服务器提供的不仅是开发效率，还能让前端不依赖后端，作为一个独立的产品模块而存在。

1. 支持get/post等多种http method；
2. 支持配置url规则，返回对应假数据；
3. 支持静态资源请求；

**js模块化方案**
1. 支持模块的独立执行上下文，依赖管理（模块管理器的基本功能)；
2. 支持同步/异步模块加载；
3. 支持合理的打包策略；

**组件化支持**
1. *开发环境* 支持组件资源（js/css/图片等）的集中管理（一个组件所依赖的资源应该在同一个组件目录下）；
2. *发布环境* 支持组件资源的自动定位（代码合并导致文件相对路径发生改变，而不需手动的替换资源引用）；
3. 按照功用对组件进行合理的划分和管理（通用控件、业务组件等）；
4. 组件资源的打包（组件依赖的js/css/模板等文件的合并和加载）；

**自动化编译**
1. 自动缓存清理（文件名md5戳）;
2. 代码打包、压缩、混淆；
3. 预编译（css预处理器：less/sass/scss/stylus，js转译语言：coffescript/dart/livescript/ES6等，模板预编译等）；
4. 自动图片优化、css sprite（可选）；
5. 资源内联，资源定位（如CDN部署时代码中的资源路径变更）；
6. 代码的非覆盖式发布；

**开发规范**
1. 代码分层，目录规范（模板、视图、路由、数据的解耦和分离，组件库的管理等）；
2. 命名规范（组件命名规范，文件命名规范，编码规范等）；
3. 技术选型（如库/框架的选择等）
4. 业务模块的拆分和通信（可选，视项目的大小而定）；
5. 子系统的拆分（可选，视项目的大小而定）；

## 集成环境实现的方案选择
**服务器环境**
开源的本地开发服务器方案有很多，比如基于grunt/gulp的各种webserver，npm上有一大堆。但是普遍比较简陋，要么只支持get方法，要么不支持独立的url配置文件，一怒之下自己开发了一个简单的服务器：[spable-server](https://github.com/busyfruit/spable-server)，基于node内置服务器，不依赖任何构建工具（当然也可以配合构建工具如gurnt/gulp之类一起使用），刚好能满足以上提到的3点要求，如果有新的功能要求也可以继续扩展。    
如果前端依赖php环境，比如使用了smarty模板引擎，采用php5.4+的内置服务器，配合一个极简的php框架，比如[Slim](http://www.slimframework.com/)，也是一个不错的选择，但这里只讨论单页面的开发环境。

**模块化方案**
提到模块化，首先想到的肯定是CMD/AMD，基于CMD规范的requirejs出现时间最早，广为人知。但是个人认为在前端发展日新月异的今天，CMD/AMD注定是一个临时的模块化替代品，迟早会被淘汰。在模块打包方面，requirejs提供了一个叫r.js的打包工具，seajs有基于服务器端combo的解决方案，但这r.js的打包方式有很明显的硬伤：要么所有模块全部打成一个包，要么全部单独异步加载。（我曾今见过一些基于requirejs的站点，一次页面跳转发出了20+个异步请求。）而基于cmobo的seajs除了需要服务器的支持，打包配置又过于繁琐难以维护。

另外一个较新的模块化方案[browserify](http://browserify.org/)，也存在同样的问题，它最大的卖点是直接使用commonJS的模块化，并且能把node的内置模块移至到前端来使用，想法很不错，但是目前的实际生产中并不适用。  

我最终的选择是[webpack](http://webpack.github.io/)，正如官网上面所说，webpack将整个依赖树分隔成“独立的块”（chunks）按需加载，采用“代码分割”（Code Splitting）的方式，将代码中用特定语法表明要进行分割的部分抽离出来将他们打成独立的chunk，在需要的时候再去加载。听起来好像跟requirejs的异步加载没有区别？看代码：

```
/**
* 打包时，view1.js + widgetA.js会打成一个chunk，
* view2.js + widgetB.js + somelib.js会打成另外一个chunk。
*/

// in view1.js
module.exports = function () {
	var widgetA = require('path/to/widget/widgetA.js');
	someLink.addEventListener('click', function (e) {
		e.preventDefault();`
		require.ensure([], function (require) {
			var view2 = require('path/to/view/view2.js');
			// render view2 ...
		});
	});
};

// in view2.js
module.exports = function () {
	var widgetB = require('path/to/widget/widgetB.js');
	var somelib = require('path/to/lib/somelib.js');
	// do something ...
};
```
webpack刚好能满足我对大型的单页面应用打包的设想：

1.**全局的库文件打成一个包，并暴露出全局变量**
比如我们采用jQuery+Backbone+underscore来开发，那么这三个库文件是一个整体，三个变量名都全局可用。
>这样做的好处是，首先不需要每个模块中都去require一遍库文件；其次，由于库文件的更新频率非常低，而业务代码更新频率非常高（如果是一个快速发展中的产品，一天发布多次很正常），将库文件和业务代码分开打包能够保证库文件的缓存长期有效，更新的只是业务代码。我们甚至可以使用manifest/localstorage等方式将库文件缓存到本地。  

2.**每次交互最多只发出一次资源请求**
假如我们以“页面”作为基本的功能单元，那么每个页面所依赖的全部css、js、tpl等都能在一次请求中返回；

此外，webpack还有一些其他的特点：  
- webpack认为所有的静态资源都应该是一个模块（不仅仅是js），这样css、tpl等都能在打包的过程中进行最优化加载管理；  
- webpack采用node的模块管理方式管理前端的库依赖，我们不再需要去jQuery官网下载一个代码文件放到目录中，直接用npm安装并require即可。（比较接近server端的包管理方式了~）

## 构建工具 Grunt vs Gulp
我的结论：Grunt和Gulp都存在一些缺陷，如果是要打造一个通用的集成化方案，最好还是基于node、python等来开发。  
先说Grunt的缺陷：
1.Grunt基于配置来构建编译流程，随便几步编译处理都会产生很长很长的代码文件，配置文件本身的维护都成问题。
> 以将less编译成css并提供压缩和未压缩两个版本的代码为例，Grunt的代码量是gulp的3倍左右。

2.文件的多步处理依赖临时文件夹
> 考虑复杂点的编译场景，将less文件中的图片路径进行自动替换，再编译成css，最后压缩，这中间依赖3次临时文件夹的过度。

3.配置的灵活性有限，难以处理复杂的需求

4.违背单一职责
> 比如对文件进行重命名，这步操作可能在uglify插件中进行，也可能在concat插件中进行，取决于工作流的最后一个环节是谁，插件本身需要负责很多本不该负责的操作。

5.性能低下
> grunt全部采用node的同步API，再加上临时文件夹的过度，导致频繁的文件读写。可能有人觉得反正是本地编译，性能不那么重要。其实不然，如果启动watch，每次save代码都要等上超过3s才能看效果，开发体验会变得非常糟糕。

再说Gulp：
gulp相对grunt来说确实做了很多改进，异步、基于Stream的构建，遵循unix设计哲学（每个插件只负责单一的功能）等等。但我在使用的过程中也遇到一些棘手的问题：

1.号称全部基于Stream，其实很多插件的工作都是读取整个文件Buffer来完成的，并不支持stream的模式，为此gulp提供了isStream和isBuffer的API来做区别；
2.过于专注于Stream，Stream对单一类型的文件进行处理非常高效方便，但更多时候我们需要同时对两种资源联合处理，比如：编译模板时需要先获取编译过的less内容，以便将css内联进模板中，这种情况下Stream反而成为了阻碍，仍然离不开临时文件夹。

但是相比grunt，gulp相对好用。所以最终选择了gulp。

# 库/框架的选择

影响库和框架的选择的因素是多种多样的，比如业务场景、个人偏好、团队水平、兼容性要求、面向不同的端等等。这是个仁者见仁，智者见智的问题。